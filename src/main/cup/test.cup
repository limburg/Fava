package saxion.pti.generated;

import java_cup.runtime.*;
import saxion.pti.ast.BuildTree;
import saxion.pti.ast.nodes.*;
import java.util.Collections;
import java.util.LinkedList;

action code {: 	
	// Build Tree met java code, zodat onze CUP file netjes blijft & onze code compileert en makkelijk te debuggen is.
	private BuildTree buildTree = new BuildTree();

:};
parser code {::};

/**
 * Terminal definitie
 */
terminal Symbol  ELSE, WHILE, IF, SYM_BOOLEAN, STATIC, RETURN;
terminal Symbol  NEQ, EQ, EQEQ, PLUS, MINUS, ASTERICK, MOD;
terminal Symbol  FSLASH, BSLASH, LESS, LESSEQ, GREATER, GREATEREQ;
terminal Symbol  LPAREN, RPAREN, LBRACE, RBRACE,  LSQPAREN, RSQPAREN;
terminal Symbol  COMMA, SEMICOLON, VOID, SYM_INT, SYM_STRING, FALSE, TRUE, PRINT;
terminal Integer STATIC_INT;
terminal Symbol  FUNC_PRINTLN;
terminal String IDENTIFIER;
terminal String STATIC_STRING;

/**
 * Non Terminal definitie.
 */
non terminal BuildTree					 program;
non terminal AbstractNode 				 program_;
non terminal AbstractNode				 proc_decl, func_decl, var_decl;

non terminal Integer					 var_type, var_array;
non terminal LinkedList<String> 		 var_names;

non terminal LinkedList<VariableNode> 	 param_decl;
non terminal AbstractNode				 code_body, code_print;
non terminal LinkedList<ExpressionNode>	 code_params;
non terminal CallNode					 code_proc;
non terminal AssignmentNode				 code_assign;
non terminal IfNode				 		 if_decl,else_decl;
non terminal WhileNode 					 while_decl;

non terminal ExpressionNode				 expression, expr_test, expr_test_, expr_result, expr_term;
non terminal AbstractNode				 expr_fact, expr_var, expr_func;
non terminal Symbol						 expr_oper;

/**
 * Voorkeur in symbolen
 */
precedence left PLUS, MINUS;
precedence left ASTERICK, FSLASH, MOD;
precedence right ELSE;


/**
 * Grammatica regels
 */
start with program;

program		::= program_ {: RESULT = buildTree; :};
program_	::= var_decl program_  |
				proc_decl program_ |
				func_decl program_ |;

// Procedure
proc_decl 	::= 
				VOID IDENTIFIER:id 
				LPAREN param_decl:params RPAREN
				{: 
					buildTree.pushNode(new ProcedureNode(id, params)); 
				:} 
				LBRACE code_body RBRACE
				{:
					buildTree.popNode();
				:}
				;


// Function
func_decl 	::= var_type:t IDENTIFIER:id 
				LPAREN param_decl:params RPAREN
				{: 
					buildTree.pushNode(buildTree.createFunctionNode(id, t, params)); 
				:} 
				LBRACE code_body
					RETURN expression:expr SEMICOLON 
				RBRACE
				{:
					buildTree.addReturnStatement(expr);
					buildTree.popNode();
				:}
				;


// Parameters
param_decl	::= var_type:t IDENTIFIER:param var_array:a
				{:LinkedList<VariableNode> params = new LinkedList<VariableNode>();
				   params.add(buildTree.createParameter(t, param, a));
				   RESULT = params; :}|
				var_type:t IDENTIFIER:param var_array:a COMMA param_decl:prms
				{:LinkedList<VariableNode> params = new LinkedList<VariableNode>();
				   params.add(buildTree.createParameter(t, param, a));
				   params.addAll(prms);
				   RESULT = params; :}|
				{: RESULT = new LinkedList<VariableNode>(); :};
		
				
// Variabele
var_decl	::= var_type:t var_names:n var_array:a SEMICOLON				
				{: buildTree.addVariables(t,n, null, a); :}|
				var_type:t var_names:n var_array:a EQ expr_result:expr SEMICOLON
				{: buildTree.addVariables(t,n,expr, a); :};
var_names	::= IDENTIFIER:id 
				{:LinkedList<String> names = new LinkedList<String>();
				   names.add(id);
				   RESULT = names; :}|
				IDENTIFIER:id COMMA var_names:ids
				{: LinkedList<String> names = new LinkedList<String>();
				   names.add(id);
				   names.addAll(ids);
				   RESULT = names; :};
var_array	::= LSQPAREN STATIC_INT:i RSQPAREN {: RESULT = new Integer(i); :} |
				LSQPAREN RSQPAREN {: RESULT = new Integer(10); :} |;

var_type 	::= SYM_INT 		{: RESULT = sym.SYM_INT; :} | 
				SYM_STRING 		{: RESULT = sym.SYM_STRING; :} |
				SYM_BOOLEAN 	{: RESULT = sym.SYM_BOOLEAN; :};


// Code
code_body	::= var_decl code_body    | 
				code_assign code_body |	
				code_proc code_body   |
				while_decl code_body  |
				if_decl code_body     |
				code_print code_body  |;
code_print	::= PRINT LPAREN expression:e RPAREN SEMICOLON
				{: buildTree.debugMsg("Print function called");
				   buildTree.addCode( new PrintNode(e)); :};
code_assign	::= IDENTIFIER:id EQ expression:e SEMICOLON 
				{: buildTree.debugMsg("Assignment to var: " + id ); 
				   buildTree.addCode( new AssignmentNode(id,e) ); :};
code_proc	::= IDENTIFIER:id LPAREN code_params:params RPAREN SEMICOLON
				{: buildTree.debugMsg("Call to proc/func: " + id ); 
				   buildTree.addCode( new CallNode(id,params) ); :};
code_params ::= expression:e 
				{: LinkedList<ExpressionNode> d =  new LinkedList<ExpressionNode>();
				   d.add(e);
				   RESULT = d;
				:} | 
				expression:e COMMA code_params:prs 
				{: LinkedList<ExpressionNode> d = new LinkedList<ExpressionNode>();
				   d.add(e);
				   d.addAll(prs);
				   RESULT = d;  :}|;


// While declaratie
while_decl	::= WHILE LPAREN expr_test:expr RPAREN
				{: 	buildTree.pushNode(new WhileNode(expr)); :}
				LBRACE code_body RBRACE else_decl
				{: 	buildTree.popNode(); :};
				
// If/Else declaratie
if_decl		::= IF LPAREN expr_test:expr RPAREN
				{: 	buildTree.pushNode(new IfNode(expr)); :}
				LBRACE code_body RBRACE 
				{: 	buildTree.popNode(); :} else_decl;
else_decl	::= ELSE LPAREN expr_test:expr RPAREN 
				{: 	buildTree.pushNode(new IfNode(expr)); :}
				LBRACE code_body RBRACE 
				{: 	buildTree.popNode(); :} else_decl |
				ELSE 
				{: 	buildTree.pushNode(new IfNode(null)); :}
				LBRACE code_body RBRACE 
				{: 	buildTree.popNode(); :} | 
				;
				
// Topdomein van een expressie
expression	::= expr_test:e 		{:	buildTree.debugMsg("boolean Expression");
										RESULT = e; :} | 
				expr_result:e 		{: 	buildTree.debugMsg("result Expression");
										RESULT = e; :};


// Vergelijkings expressie
expr_test	::= expr_result:v EQEQ:d expr_result:r 
									{: ExpressionNode e = new ExpressionNode(v,d,r);
									   r.setLeft(e);
									   RESULT = e;
									 :} |
				expr_result:v NEQ:d expr_result:r  
									{: ExpressionNode e = new ExpressionNode(v,d,r);
									   r.setLeft(e);
									   RESULT = e;
									 :} |
				expr_result:v LESS:d expr_result:r 
									{: ExpressionNode e = new ExpressionNode(v,d,r);
									   r.setLeft(e);
									   RESULT = e;
									 :} |
           		expr_result:v LESSEQ:d expr_result:r 
									{: ExpressionNode e = new ExpressionNode(v,d,r);
									   r.setLeft(e);
									   RESULT = e;
									 :} |
           		expr_result:v GREATER:d expr_result:r 
									{: ExpressionNode e = new ExpressionNode(v,d,r);
									   r.setLeft(e);
									   RESULT = e;
									 :} |
           		expr_result:v GREATEREQ:d expr_result:r
           							{: ExpressionNode e = new ExpressionNode(v,d,r);
									   r.setLeft(e);
									   RESULT = e;
									 :} ;
           		
// Uitkomst expressie
expr_result	::= expr_term:v PLUS:a expr_result:r  
									{: ExpressionNode e = new ExpressionNode(v,a,r);
									   r.setLeft(e);
									   RESULT = e;
									 :} |
				expr_term:v MINUS:a expr_result:r 
									{: ExpressionNode e = new ExpressionNode(v,a,r);
									   r.setLeft(e);
									   RESULT = e;
									 :} |
				expr_term:t 
									{: RESULT = new ExpressionNode(t); :} ;
expr_term 	::= expr_fact:v expr_oper:o expr_term:r 
									{: ExpressionNode e = new ExpressionNode(v,o,r);
									   r.setLeft(e);
									   RESULT = e;
									 :} |
				expr_fact:f 		{: RESULT = new ExpressionNode(f); :} ;
expr_oper	::= ASTERICK:a 			{: RESULT = a; :} | 
				MOD:a 				{: RESULT = a; :} | 
				FSLASH:a 			{: RESULT = a; :};
expr_fact	::= IDENTIFIER:id var_array:a		
									{: RESULT = new CallVarNode(id,a); :}|
				STATIC_INT:i 		{: RESULT = new StaticValueNode<Integer>(i); :} | 
				STATIC_STRING:s 	{: RESULT = new StaticValueNode<String>(s);  :} | 
				TRUE   				{: RESULT = new StaticValueNode<Boolean>(true);  :} | 
				FALSE  				{: RESULT = new StaticValueNode<Boolean>(false);  :} | 
				code_proc:c 		{: RESULT = c; :};



