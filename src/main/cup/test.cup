package saxion.pti.generated;

import java_cup.runtime.*;
import saxion.pti.ast.BuildTree;
import saxion.pti.ast.nodes.*;
import java.util.Collections;
import java.util.LinkedList;

action code {: 	
	// Build Tree met java code, zodat onze CUP file netjes blijft & onze code compileert en makkelijk te debuggen is.
	private BuildTree buildTree = new BuildTree();

:};
parser code {::};

/**
 * Terminal definitie
 */
terminal Symbol  ELSE, WHILE, IF, SYM_BOOLEAN, STATIC, RETURN;
terminal Symbol  NEQ, EQ, EQEQ, PLUS, MINUS, ASTERICK, MOD;
terminal Symbol  FSLASH, BSLASH, LESS, LESSEQ, GREATER, GREATEREQ;
terminal Symbol  LPAREN, RPAREN, LBRACE, RBRACE,  LSQPAREN, RSQPAREN;
terminal Symbol  COMMA, SEMICOLON, VOID, SYM_INT, SYM_STRING;
terminal Integer STATIC_INT;
terminal Symbol  FUNC_PRINTLN;
terminal String IDENTIFIER;
terminal String STATIC_STRING;

/**
 * Non Terminal definitie.
 * Non terminals die eindigen op _ zijn toegevoegd om * en + uit BNF op te vangen in CUP.
 */
non terminal BuildTree					 program;
non terminal AbstractNode 				 program_;
non terminal AbstractNode				 proc_decl, func_decl, var_decl;

non terminal Integer					 var_type;
non terminal LinkedList<String> 		 var_names;

non terminal LinkedList<VariableNode<?>> param_decl;
non terminal AbstractNode				 code_body, code_params;
non terminal CallNode					 code_proc;
non terminal AssignmentNode				 code_assign;
non terminal IfNode				 		 if_decl,else_decl;
non terminal WhileNode 					 while_decl;

non terminal ExpressionNode				 expression, expr_test, expr_test_, expr_result, expr_term;
non terminal AbstractNode				 expr_fact, expr_var, expr_func;
non terminal Symbol						 expr_oper;

/**
 * Voorkeur in symbolen
 */
precedence left PLUS, MINUS;
precedence left ASTERICK, FSLASH, MOD;
precedence right ELSE;


/**
 * Grammatica regels
 */
start with program;

program		::= program_ {: RESULT = buildTree; :};
program_	::= var_decl program_  |
				proc_decl program_ |
				func_decl program_ |;

// Procedure
proc_decl 	::= 
				VOID IDENTIFIER:id 
				LPAREN param_decl:params RPAREN
				{: 
					buildTree.pushNode(new ProcedureNode(id, params)); 
				:} 
				LBRACE code_body RBRACE
				{:
					buildTree.popNode();
				:}
				;


// Function
func_decl 	::= var_type IDENTIFIER:id 
				LPAREN param_decl:params RPAREN
				{: 
					buildTree.pushNode(new FunctionNode(id, params)); 
				:} 
				LBRACE code_body
					RETURN expression SEMICOLON 
				RBRACE
				{:
					buildTree.popNode();
				:}
				;


// Parameters
param_decl	::= var_type:t IDENTIFIER:param
				{:LinkedList<VariableNode<?>> params = new LinkedList<VariableNode<?>>();
				   params.add(buildTree.createParameter(t, param));
				   RESULT = params; :}|
				var_type:t IDENTIFIER:param COMMA param_decl:prms
				{:LinkedList<VariableNode<?>> params = new LinkedList<VariableNode<?>>();
				   params.add(buildTree.createParameter(t, param));
				   params.addAll(prms);
				   RESULT = params; :}|
				{: RESULT = new LinkedList<VariableNode<?>>(); :};
		
				
// Variabele
var_decl	::= var_type:t var_names:n SEMICOLON				
				{: buildTree.addVariables(t,n, null); :}|
				var_type:t var_names:n EQ expr_result SEMICOLON
				{: buildTree.addVariables(t,n,null); :};
var_names	::= IDENTIFIER:id 
				{:LinkedList<String> names = new LinkedList<String>();
				   names.add(id);
				   RESULT = names; :}|
				IDENTIFIER:id COMMA var_names:ids
				{: LinkedList<String> names = new LinkedList<String>();
				   names.add(id);
				   names.addAll(ids);
				   RESULT = names; :};
var_type 	::= SYM_INT {: RESULT = sym.SYM_INT; :} | SYM_STRING {: RESULT = sym.SYM_STRING; :};


// Code
code_body	::= var_decl code_body    | 
				code_assign code_body |	
				code_proc code_body   |
				while_decl code_body  |
				if_decl code_body     |;
code_assign	::= IDENTIFIER:id EQ expression:e SEMICOLON 
				{: buildTree.debugMsg("Assignment to var: " + id ); 
				   buildTree.addCode( new AssignmentNode(id,e) ); :};
code_proc	::= IDENTIFIER:id LPAREN code_params:params RPAREN SEMICOLON
				{: buildTree.debugMsg("Call to proc/func: " + id ); 
				   buildTree.addCode( new CallNode(id,null) ); :};
code_params ::= expression | expression COMMA code_params |;


// While declaratie
while_decl	::= WHILE LPAREN expr_test RPAREN
				{: 	buildTree.pushNode(new WhileNode()); :}
				LBRACE code_body RBRACE else_decl
				{: 	buildTree.popNode(); :};
				
// If/Else declaratie
if_decl		::= IF LPAREN expr_test RPAREN
				{: 	buildTree.pushNode(new IfNode()); :}
				LBRACE code_body RBRACE 
				{: 	buildTree.popNode(); :} else_decl;
else_decl	::= ELSE LPAREN expr_test RPAREN 
				{: 	buildTree.pushNode(new IfNode()); :}
				LBRACE code_body RBRACE 
				{: 	buildTree.popNode(); :} else_decl |
				ELSE 
				{: 	buildTree.pushNode(new IfNode()); :}
				LBRACE code_body RBRACE 
				{: 	buildTree.popNode(); :} | 
				{: 	buildTree.popNode(); :};
				
// Topdomein van een expressie
expression	::= expr_test:e 		{:	buildTree.debugMsg("boolean Expression");
										RESULT = e; :} | 
				expr_result:e 		{: 	buildTree.debugMsg("result Expression");
										RESULT = e; :};


// Vergelijkings expressie
expr_test	::= expr_result:v EQEQ:d expr_result:r 
									{: ExpressionNode e = new ExpressionNode(v,d,r);
									   r.setLeft(e);
									   RESULT = e;
									 :} |
				expr_result:v NEQ:d expr_result:r  
									{: ExpressionNode e = new ExpressionNode(v,d,r);
									   r.setLeft(e);
									   RESULT = e;
									 :} |
				expr_result:v LESS:d expr_result:r 
									{: ExpressionNode e = new ExpressionNode(v,d,r);
									   r.setLeft(e);
									   RESULT = e;
									 :} |
           		expr_result:v LESSEQ:d expr_result:r 
									{: ExpressionNode e = new ExpressionNode(v,d,r);
									   r.setLeft(e);
									   RESULT = e;
									 :} |
           		expr_result:v GREATER:d expr_result:r 
									{: ExpressionNode e = new ExpressionNode(v,d,r);
									   r.setLeft(e);
									   RESULT = e;
									 :} |
           		expr_result:v GREATEREQ:d expr_result:r
           							{: ExpressionNode e = new ExpressionNode(v,d,r);
									   r.setLeft(e);
									   RESULT = e;
									 :} ;
           		
// Uitkomst expressie
expr_result	::= expr_term:v PLUS:a expr_result:r  
									{: ExpressionNode e = new ExpressionNode(v,a,r);
									   r.setLeft(e);
									   RESULT = e;
									 :} |
				expr_term:v MINUS:a expr_result:r 
									{: ExpressionNode e = new ExpressionNode(v,a,r);
									   r.setLeft(e);
									   RESULT = e;
									 :} |
				expr_term:t 
									{: RESULT = new ExpressionNode(t); :} ;
expr_term 	::= expr_fact:v expr_oper:o expr_term:r 
									{: ExpressionNode e = new ExpressionNode(v,o,r);
									   r.setLeft(e);
									   RESULT = e;
									 :} |
				expr_fact:f 		{: RESULT = new ExpressionNode(f); :} ;
expr_oper	::= ASTERICK:a 			{: RESULT = a; :} | 
				MOD:a 				{: RESULT = a; :} | 
				FSLASH:a 			{: RESULT = a; :};
expr_fact	::= IDENTIFIER:id 		{: RESULT = new CallVarNode(id); :}|
				STATIC_INT:i 		{: RESULT = new StaticValueNode<Integer>(i); :} | 
				STATIC_STRING:s 	{: RESULT = new StaticValueNode<String>(s);  :} | 
				code_proc:c 		{: RESULT = c; :};



