package saxion.pti.generated;

import java_cup.runtime.*;
import saxion.pti.ast.BuildTree;
import saxion.pti.ast.nodes.*;
import java.util.Collections;
import java.util.LinkedList;

action code {: 	
	// Build Tree met java code, zodat onze CUP file netjes blijft & onze code compileert en makkelijk te debuggen is.
	private BuildTree buildTree = new BuildTree();

:};
parser code {::};

/**
 * Terminal definitie
 */
terminal Symbol  ELSE, WHILE, IF, SYM_BOOLEAN, STATIC, RETURN;
terminal Symbol  NEQ, EQ, EQEQ, PLUS, MINUS, ASTERICK, MOD;
terminal Symbol  FSLASH, BSLASH, LESS, LESSEQ, GREATER, GREATEREQ;
terminal Symbol  LPAREN, RPAREN, LBRACE, RBRACE,  LSQPAREN, RSQPAREN;
terminal Symbol  COMMA, SEMICOLON, VOID, SYM_INT, SYM_STRING;
terminal Integer STATIC_INT;
terminal Symbol  FUNC_PRINTLN;
terminal String IDENTIFIER;
terminal String STATIC_STRING;

/**
 * Non Terminal definitie.
 * Non terminals die eindigen op _ zijn toegevoegd om * en + uit BNF op te vangen in CUP.
 */
non terminal AbstractNode 				 program, program_;
non terminal AbstractNode				 proc_decl, func_decl, var_decl;

non terminal Integer					 var_type;
non terminal LinkedList<String> 		 var_names;

non terminal LinkedList<VariableNode<?>> param_decl;
non terminal AbstractNode				 rule_body, expression;

/**
 * Voorkeur in symbolen
 */
precedence left PLUS, MINUS;
precedence left ASTERICK, FSLASH, MOD;
precedence right ELSE;


/**
 * Grammatica regels
 */
start with program;

program		::= program_ ;
program_	::= var_decl program_  |
				proc_decl program_ |
				func_decl program_ |;

// Procedure
proc_decl 	::= VOID IDENTIFIER:id 
				LPAREN param_decl:params RPAREN
				LBRACE rule_body RBRACE;


// Function
func_decl 	::= var_type IDENTIFIER:id 
				LPAREN param_decl:params RPAREN
				LBRACE rule_body
					RETURN expression SEMICOLON 
				RBRACE;

// Parameters
param_decl	::= var_type:t IDENTIFIER:param
				{:LinkedList<VariableNode<?>> params = new LinkedList<VariableNode<?>>();
				   params.add(buildTree.createParameter(t, param));
				   RESULT = params; :}|
				var_type:t IDENTIFIER:param COMMA param_decl:prms
				{:LinkedList<VariableNode<?>> params = new LinkedList<VariableNode<?>>();
				   params.add(buildTree.createParameter(t, param));
				   params.addAll(prms);
				   RESULT = params; :}|
				{: RESULT = new LinkedList<VariableNode<?>>(); :};
				
// Variabele
var_decl	::= var_type:t var_names:n SEMICOLON				
				{: buildTree.addVariables(t,n, null); :}|
				var_type:t var_names:n EQ expression:e SEMICOLON
				{: buildTree.addVariables(t,n,null); :};
var_names	::= IDENTIFIER:id 
				{:LinkedList<String> names = new LinkedList<String>();
				   names.add(id);
				   RESULT = names; :}|
				IDENTIFIER:id COMMA var_names:ids
				{: LinkedList<String> names = new LinkedList<String>();
				   names.add(id);
				   names.addAll(ids);
				   RESULT = names; :};
var_type 	::= SYM_INT {: RESULT = sym.SYM_INT; :} | SYM_STRING {: RESULT = sym.SYM_STRING; :};

// Rules
rule_body	::= ELSE;
expression	::= ELSE;
